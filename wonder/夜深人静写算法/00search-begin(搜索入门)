### 搜索入门

#### 搜索算法的原理

- 搜索算法的原理就是枚举。利用计算机的高性能，给出人类制定好的规则，枚举出所有可行的情况，找到可行解或者最优解。
- 比较常见的搜索算法是 深度优先搜索（又叫深度优先遍历） 和 广度优先搜索（又叫广度、宽度优先遍历）。各种图论的算法基本都是依靠这两者进行展开的。
- 深度优先搜索一般用来求可行解(前后逻辑有连接或是否可达)，利用剪枝进行优化，在树形结构的图上用处较多；而广度优先搜索一般用来求最优解(层数最小)，配合哈希表进行状态空间的标记，从而避免重复状态的计算；



#### 深度优先搜索

##### **DFS  **

Deep First Search 深度优先算法

###### 算法原理

简言之:一直往下走,走不通(自定义规则,一般为到达最底端)换条路再走,直到无路可走(全部遍历完).

> 选择一个起始点 u 作为 **当前结点**，执行如下操作：
> a. 访问 当前结点，并且标记该结点已被访问，然后跳转到 b；
> b. 如果存在一个和 当前结点 相邻并且尚未被访问的结点 v，则将 v 设为 当前结点，继续执行 a；
> c. 如果不存在这样的 v，则进行回溯，回溯的过程就是回退 当前结点；

###### 实现方法:

1. 利用一个栈保存当前节点,每次回溯时出栈
2. 递归实现

###### 实例场景:

1. 求阶乘

   ```c++
   int dfs(int n) {
       return !n ? 1 : n * dfs(n-1);
   }
   ```

2. 斐波那契数列第N项

    ```c++
   int dfs(unsigned int n) {
       if(n <= 1) {
           return 1;
       }
       return dfs(n-1) + dfs(n-2);
   }
    ```

3. n个数的全排列

   ```c++
   // n个数围成环深度遍历
   void dfs(int depth) {                                  // 1
       if(depth == MAXN) {                                // 2
           dfs_print();
           return;
       }
       for(int i = 1; i <= MAXN; ++i) {
           int v = i;
           if(!visit[v]) {                                // 3
               dfs_add(v);                                // 4             
               dfs(depth+1);
               dfs_dec(v);
           }
       }
   }
   void dfs_add(int u) {
       visit[u] = true;
       ans[ansSize] = u;
       ++ansSize;
   }
   
   void dfs_dec(int u) {
       --ansSize;
       visit[u] = false;
   }
   ```

   > 1）这里的 depth参数用来做计数用，表明本次遍历了多少个结点；
   > 2）当遍历元素达到 MAXN个的时候，输出访问的元素列表；
   > 3）visit[v]用来判断  这个元素是否有访问过；
   > 4）dfs_add和 dfs_dec分别表示将结点从访问列表加入和删除；

4. 高级应用

   **a. 枚举**

   - 数据范围较小的的排列、组合的穷举。

   **b. 容斥原理**

   - 主要用于组合数学中的计数统计，会在后面的章节详细介绍。

   **c. 基于状态压缩的动态规划**

   - 一般解决棋盘摆放问题， 进制表示状态，然后利用深搜进行状态转移，会在后面的章节详细介绍。

   **d.记忆化搜索**

   - 某个状态已经被计算出来，就将它 cache 住，利用数组或者哈希表将它的值存储下来，下次要用的时候不需要重新求，此所谓记忆化。本章节会详细讲到记忆化搜索的应用范围。

   **e.有向图强连通分量**

   - 经典的 算法，求解 问题的基础，会在后面的章节详细介绍。

   **f. 无向图割边割点和双连通分量**

   - 经典的 算法，会在后面的章节详细介绍。

   **g. LCA 最近公共祖先**

   - 最近公共祖先递归求解，会在后面的章节详细介绍。

   **h.博弈**

   - 利用深搜计算SG值，会在后面的章节详细介绍。

   **i.二分图最大匹配**

   - 经典的匈牙利算法，最小顶点覆盖、最大独立集、最小值支配集 向二分图的转化，会在后面的章节详细介绍。

   **j.欧拉回路**

   - 经典的圈套圈算法，会在后面的章节详细介绍。

   **k.K短路**

   - 依赖数据，数据不卡的话可以采用2分答案 + 深搜；也可以用广搜 + A*。

   **l. 线段树**

   - 二分经典思想，配合深搜枚举左右子树，求和、最值等问题，会在后面的章节详细介绍。

   **m. 最大团**

   - 极大完全子图的优化算法，会在后面的章节详细介绍。

   **n. 最大流**

   - EK算法求任意路径中有涉及，会在后面的章节详细介绍。

   **o. 树形DP**

   - 即树形动态规划，父结点的值由各个子结点计算得出，会在后面的章节详细介绍。



##### 基于DFS的记忆化搜索

###### 算法原理

> 类似动态规划的思想，每次将已经计算出来的状态的值存储到数组或者哈希表中，下次需要的时候直接记录的值，避免重复计算。

- 我们用函数 `DFS(i,j)`表示从(1,1)到 (i,j)可以取得金矿的最大值，那么要到达 (i,j)这个点，要么是从(i-1,j)过来，要么是从(i,j-1)过来，所以就有如下方程：
  $$
  DFS(i,j) = gold[i][j] + max{DFS(i,j-1),DFS(i-1,j)}
  $$

- 满足递归性质就可以进行深度优先搜索了，于是遇到了和求斐波那契数列一样的问题， 可能会被计算两次，每个结点都被计算两次的话复杂度就是指数级了。

- 所以这里我们可以利用一个二维数组，令`D[i][j]=DFS(i,j)` ，初始化所有的`D[i][j]=-1` ，表示尚未计算，每次搜索到(i,j)这个点时，检查`D[i][j]`的值，如果为 -1，则进行计算，将计算结果赋值给`D[i][j`]；否则直接返回`D[i][j`]的值。

- 记忆化搜索虽然叫搜索，实际上还是一个动态规划问题，能够记忆化搜索的一般都能用动态规划求解，但是记忆化搜索的编码更加直观、易写。

###### 算法实现

```c++
int dfs(int i, int j) {
    if(i == 0 && j == 0) {                          // 1
        return D[0][0] = gold[0][0];
    }
    if(i < 0 || j < 0) {                            // 2
        return 0;
    }
    if(D[i][j] != -1) {                             // 3
        return D[i][j];
    }
    return D[i][j] = gold[i][j] + max(dfs(i-1,j), dfs(i, j-1));
    // 4
}
```

> - 1）当i 和 j都为 0，代表起点，直接返回起点的金矿值；
> - 2）当i<0 或者j<0 时， 代表是个不合法的点，则直接返回最小值 0；
> - 3）当`D[i][j]`不等于默认值 -1 时，说明之前已经通过其他途径遍历到(i,j)这个点并且已经计算过最优值，可以直接返回。
> - 4）利用递归计算(i,j)这个点的最优值，并且赋值给`D[i][j]`作为记忆化。

```shell
// output:
0 0 0 1 1 1
0 0 2 2 7 7
0 3 3 8 8 8
1 3 5 8 8 8
```

##### 基于DFS的剪枝

###### 算法原理

> - 搜索的过程可以看作是从树根出发，遍历一棵倒置的树——搜索树的过程。而剪枝，顾名思义，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝（原话取自1999年OI国家集训队论文《搜索方法中的剪枝优化》（齐鑫））。
> - 如果我们在搜索的过程中能够清楚地知道哪些子树不可能出解，就没必要往下搜索了，也就是将连接不可能出解的子树的那根“枝条”剪掉.

剪枝遵循的原则:

**a. 正确性**

- 剪掉的子树中如果存在可行解（或最优解），那么在其它的子树中很可能搜不到解导致搜索失败，所以剪枝的前提必须是要正确；

**b. 准确性**

- 剪枝要“准”。所谓“准”，就是要在保证在正确的前提下，尽可能多得剪枝。

**c. 高效性**

- 剪枝一般是通过一个函数来判断当前搜索空间是否是一个合法空间，在每个结点都会调用到这个函数，所以这个函数的效率很重要。
- 剪枝大致可以分成两类：可行性剪枝、最优性剪枝（上下界剪枝）。

###### 可行性剪枝

- 可行性剪枝一般是处理可行解的问题，如一个迷宫，问能否从起点到达目标点之类的。

###### 最优性剪枝(上下界剪枝)

- 最优性剪枝一般是处理最优解的问题。以求两个状态之间的最小步数为例，搜索最小步数的过程：一般情况下，需要保存一个“当前最小步数”，这个最小步数就是当前解的一个下界d。在遍历到搜索树的叶子结点时，得到了一个新解，与保存的下界作比较，如果新解的步数更小，则令它成为新的下界。搜索结束后，所保存的解就是最小步数。而当我们已经搜索了k歩，如果能够通过某种方式估算出当前状态到目标状态的理论最少步数 s 时，就可以计算出起点到目标点的理论最小步数，即估价函数 h = k + s，那么当前情况下存在最优解的必要条件是h < d，否则就可以剪枝了。最优性剪枝是不断优化解空间的过程。

##### 基于DFS的A*(迭代加深,IDA*)

###### 算法原理

> 迭代加深算法原理如下：
> 1、枚举深度。
> 2、根据限定的深度进行 `DFS`，并且利用估价函数进行剪枝。

###### 算法实现

```c++
// 算法原理本身很简单，难点在于估价函数的选取和实现。
void IDA_Star(int startState) {
    int maxDepth = 0;
    while (true) {
        if(dfs(startState, 0, maxDepth)) {
            return ;
        }
        maxDepth = maxDepth + 1;
    }
}
```

###### 简单举例

#### BFS

Breadth First Search 广度优先搜索

###### 算法原理

> 选择一个起始点 u 放入一个先进先出的队列中，执行如下操作：
> a. 如果队列不为空，弹出一个队列首元素，记为 当前结点，执行b；否则算法结束；
> b. 将与 当前结点 相邻并且尚未被访问的结点的信息进行更新，并且全部放入队列中，继续执行a；

- 维护广搜的数据结构是队列和哈希表，也就是很多数据结构书上所说的 表，哈希表主要是用来标记状态的，比如某个状态并不是一个整数，可能是一个字符串，就需要用字符串映射到一个整数，可以自己写个散列哈希表，不建议用STL的map，效率奇低。
- 广搜最基础的应用是用来求图的最短路。

###### 算法实现

```c++
const int inf = -1;

void bfs(int u) {
    queue <int> q;
    memset(dis, inf, sizeof(dis));               // 1
    dis[u] = 0;                        
    q.push(u);
    while(!q.empty()) {
        u = q.front();                           // 2
        q.pop();
        
        for(int v = 1; v <= n; ++v) {
            if(!adj[u][v]) continue;             // 3
            if(dis[v] != inf) continue;          // 4
            
            dis[v] = dis[u] + 1;                 // 5
            q.push(v);
        }
    }
}
```

> - 1）`dis[u]`数组用来标记从起点到 u 的最短距离，初始化为 -1 代表无限远；
> - 2）每次从队列中弹出一个元素，这里队列采用 STL 的动态队列；
> - 3）`adj[u][v]=0`代表不连通，则直接跳过；
> - 4）`dis[v] != inf`代表 v 这个结点已经访问过，则直接跳过；
> - 5）扩展下一个结点，并且放入队列中，等待下次弹出；

###### 基础应用

**a. 最短路**

- bellman-ford最短路的优化算法SPFA，主体是利用BFS实现的，会在后面的章节详细介绍。
- 绝大部分四向、八向迷宫的最短路问题。

**b. 拓扑排序**

- 首先找入度为0的点入队，弹出元素执行“减度”操作，继续将减完度后入度为0的点入队，循环操作，直到队列为空，经典BFS操作，会在后面的章节详细介绍。

**c. FloodFill**

- 经典洪水灌溉算法。

###### 高级应用

**a. 差分约束**

- 数形结合的经典算法，利用SPFA来求解不等式组，会在后面的章节详细介绍。

**b. 稳定婚姻**

- 二分图的稳定匹配问题，试问没有稳定的婚姻，如何有心思学习算法，所以一定要学好BFS啊。

**c. AC自动机**

- 字典树 + KMP + BFS，在设定失败指针的时候需要用到BFS。
- 详细算法参见：http://www.cppblog.com/menjitianya/archive/2014/07/10/207604.html

**d. 矩阵二分**

- 矩阵乘法的状态转移图的构建可以采用BFS，会在后面的章节详细介绍。

**e. 基于k进制的状态压缩搜索**

- 这里的k一般为2的幂，状态压缩就是将原本多维的状态压缩到一个k进制的整数中，便于存储在一个一维数组中，往往可以大大地节省空间，又由于k为2的幂，所以状态转移可以采用位运算进行加速，HDU1813 和 HDU3278 以及 HDU3900 都是很好的例子。

**f. 基于A\*的广度优先搜索**

- 在搜索的时候，结点信息要用堆（优先队列）维护大小，即能更快到达目标的结点优先弹出。
- 对于 A*算法，会在后面的章节详细介绍。

**g.双向广搜**

- 适用于 起始状态 和 结束状态 都已知的情况，能够将状态空间进行开根号。
- 关于双向广搜的内容，会在后面的章节详细介绍。



2021-4-13